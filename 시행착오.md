# 시행착오

## ROS

사용 목적: ROS를 통해 카메라를 효율적으로 사용하고, 향후 ROS기반의 로봇공학에 접근하기 위해


Jetbot의 ROS 설치는 아래의 사이트들을 참조 하였다.

출처: <https://github.com/dusty-nv/jetbot_ros>


### Jetbot motor drive

#### Problem 1 motor library
현재 jetbot 라이브러리에서 지원해주는 motor 구동은 python3에서 가능하다.

하지만 ROS python2 기반이기 때문에 이에 따른 python2와 라이브러리 재설치를 해야한다.

```
sudo apt-get install python-pip
```

위의 사이트에서는 이에 대해 설명 되었지만 현재 python3로 defalut되어 있어

다른 블로그를 참고하여 python2에 설치하는 법을 찾았다. 

```
pip2 install Adafruit-MotorHAT
pip2 install Adafruit-SSD1306
```
출처:http://blog.naver.com/PostView.nhn?blogId=zeta0807&logNo=222084985732&parentCategoryNo=&categoryNo=&viewDate=&isShowPopularPosts=false&from=postView

이후 과정은 1번째 과정과 동일하게 진행할 수 있다.

#### Problem 2 not working motor
이전 problem1을 통해 라이브러리를 옳바르게 설치하여도 모터가 동작하지 않는 문제가 발생한다.

이는 i2c통신을 하는 모터드라이브의 확률이 있으므로 다음의 코드를 통해 i2c 연결 상태를 확인 해 본다.

```
sudo i2cdetect -y -r 0
sudo i2cdetect -y -r 1
```
하지만 이때 0x40 또는 0x41에 연결이 확인 되었으나 모터가 동작 하지 않는 경우가 있다.

이는 i2c통신을 하는 모터 드라이브와 라이브러리가 잘못 매칭되어 발생하는 문제로 추정 된다.

이러한 경우 모터 라이브러리에 접근하여 수정할 필요가 있다.

우선 1번째 설치 과정을 수행하면 jetbot_ros/scripts/jetbot_motors.py 노드를 찾을 수 있다.

여기서 18번째 줄의 motor_ID 를 3으로 그러면 ROS예제를 실행 시켰을 때 오른쪽 모터가 돌아 가는 것을 확인 할 수 있다.

이후 왼쪽 바퀴는 Adafruit_MotorHAT라이브러리 경로에 접근 하여 수정해야 한다.

```
cd ./.local/lib/python2.7/site-packages
```

로 들어가서 Adafruit-MotorHAT 라이브러리를 찾는다. (이 근처인데 정확한 경로는 기억이 나지 않습니다.)

이후 Adafruit_DCMotor 클래스를 아래의 코드와 같이 수정하면 왼쪽 모터가 옳바르게 동작한다.

```python
class Adafruit_DCMotor:
    def __init__(self, controller, num):
        self.MC = controller
        self.motornum = num
        pwm = in1 = in2 = 0

        if (num == 0):
                 pwm = 13
                 in2 = 6
                 in1 = 9
        elif (num == 1):
                 pwm = 1
                 in2 = 0
                 in1 = 5
        elif (num == 2):
                 pwm = 7
                 in2 = 12
                 in1 = 11
        elif (num == 3):
                 pwm = 2
                 in2 = 3
                 in1 = 4
```
이는 아래의 블로그를 참고하였으며 질문자(znzl0120)은 시행 착오글 작성자 입니다.

출처: <http://blog.naver.com/PostView.nhn?blogId=zeta0807&logNo=222119081765&parentCategoryNo=&categoryNo=&viewDate=&isShowPopularPosts=false&from=postView>

### OpenCV

지금 까지 모터를 동작시키으로써 모터 노드를 형성하였고 모터 노드가 정보를 전달 받을 이미지 처리 노드를 생성 해야 한다.

#### Problem 1 use webcam
이 글은 CSI 카메라가 아닌 USB 카메라를 기준으로 작성 하였습니다.

1. usb camera setting
```
sudo apt install ros-melodic-usb-cam
sudo apt-get update
ls -ltr /dev/video*
```
위의 라이브러리를 통해 카메라 환경 설치 및 카메라 유무를 확인 한다.c
추가로 아래의 명령어로 통해 현재 연결된 카메라가 지원하는 해상도와 FPS를 확인 할 수 도 있다.

```
v4l2-ctl -d /dev/video[x] --list-formats-ext
```
이 후 아래의 사이트로 가서 usb cam package를 설치를 한 후 아래의 명령어로 영상이 출력 되는지 확인 한다.

<https://github.com/ros-drivers/usb_cam>
```
roscore
rosrun usb_cam usb_cam_node
```
#### Problem 2  HSV filter
RGB 영역의 색 모델은 빛에 쉽게 영향을 받아 옳바른 필터를 작성하기 힘들지만 HSV 필터는 빛의 세기를 조절할 수 있으므로 색 필터를 설계하기에 RGB보다 적합하다.

이런 HSV 필터를 opencv 라이브러리를 통해 python 노드를 작성 했다.
```python
#!/usr/bin/env python
import rospy
import cv2
import numpy as np
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image
from sensor_msgs.msg import CompressedImage

class Hsv():
    def __init__(self):
        self.selecting_sub_image = "raw" # you can choose image type "compressed", "raw"

        if self.selecting_sub_image == "compressed":
            self._sub = rospy.Subscriber('/usb_cam/image_raw/compressed', CompressedImage, self.callback, queue_size=1)
        else:
            self._sub = rospy.Subscriber('/usb_cam/image_raw', Image, self.callback, queue_size=1)

        self.bridge = CvBridge()

    def callback(self, image_msg):

        if self.selecting_sub_image == "compressed":
            #converting compressed image to opencv image
            np_arr = np.fromstring(image_msg.data, np.uint8)
            cv_image = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
        elif self.selecting_sub_image == "raw":
            cv_image = self.bridge.imgmsg_to_cv2(image_msg, "bgr8")

        img_hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)
        lower_bound = np.array([13, 0, 66])
        upper_bound = np.array([21, 255, 255])

        img_mask = cv2.inRange(img_hsv, lower_bound, upper_bound)
        cv2.imshow('img_mask', img_mask), cv2.waitKey(1)
    def main(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('hsv')
    node = Hsv()
    node.main()                               

```
