jetbot 라이브러리에 있는 Road Following 예제를 통해 학습을 진행하기로 했다.

트랙에서 데이터를 수집하고 학습 과정을 거쳐서 완성된 모델을 테스트 해보았는데

속도가 너무 빨라서 안정적인 주행을 이루지 못하였다.

그래서 기존의 모델 구동 코드 대신
```
angle = 0.0
angle_last = 0.0
count_motor = 0
def execute(change):
    global angle, angle_last, count_motor
    image = change['new']
    xy = model(preprocess(image)).detach().float().cpu().numpy().flatten()
    x = xy[0]
    y = (0.5 - xy[1]) / 2.0
    
    x_slider.value = x
    y_slider.value = y
    
    speed_slider.value = speed_gain_slider.value
    
    angle = np.arctan2(x, y)
    pid = angle * steering_gain_slider.value + (angle - angle_last) * steering_dgain_slider.value
    angle_last = angle
    
    steering_slider.value = pid + steering_bias_slider.value
   
    if count_motor >2:
        robot.left_motor.value = max(min(speed_slider.value + steering_slider.value, 1.0)*0.95, 0.0)
        robot.right_motor.value = max(min(speed_slider.value - steering_slider.value, 1.0), 0.0)
        count_motor = 0
    else :
        robot.left_motor.value = 0
        robot.right_motor.value = 0
        count_motor = count_motor + 1

        
execute({'new': camera.value})
```
이 새로운 코드로 변경하여서 구동을 해보았다.


결과는 상당히 안정적으로 주행을 하였지만 속도가 너무 느리다는 것이 문제였고,
또 예제를 통해서 정지선에서 멈추는 동작을 하게 할 수 없을 것이라고 판단했다.
그래서 상의 끝에 딥러닝으로 문제를 해결하자는 의견으로 결론이 났다.


먼저 딥러닝 라이브러리를 다운받아 jetbot 환경과 대회 룰에 맞게 코드를 수정했다.
그 후 데이터를 수집하고 모델훈련을 해보았는데 훈련 도중 계속 error 값이 발산하는 문제가 생겼다.
이 문제는 기존 코드는 직진,좌,우 3가지 동작만 가지고 훈련이 이루어지게 설정해놓았는데
정지3초 동작을 새로 넣어서 함수의 value값이 안맞는 것이 원인이었다.



이후 트랙에서 주행과 정지3초, 여러 돌발상황들의 데이터를 잘 정제해서
학습을 시킨 뒤 자율주행을 해보았다.
주행도 안정적이었고 속도도 괜찮았지만, 정지하는 과정에서 코드에 time.sleep이 들어가있는데
정지선을 인식하면 정지3초 동작을 계속 반복하는 경우가 생겼다.
이 문제를 해결하기 위해 count변수를 새로 지정하여 동작을 1번만 하게끔 수정했다.
```
```

